[{"content":"整体架构 家 国内 国外 r2s ( wireguard + udptunnel smartdns) -\u0026gt; ax9000 -\u0026gt; 光猫) vps ( bind dnscrypt-proxy ） vps ( caddy wireguard + udptunnel ) 整套方案的方针是\n减少复杂度，任何情况下不要影响任何不参与其中的设备，因为家里还有其他人用。所以采用旁网关的方式 尽量采用由可信的第一方直接提供的技术/组件。作者跑路，团队内讧导致使用的版本无人维护，经常出现破坏性变动，作者夹带私货等现象实在是太多了，所以采用wireguard作为vpn方案，其他xray v2ray/v2fly trojan ss ssr之类的通通pass\u0026hellip;搞出这么多东西来就足以说明了由多不靠谱 传输协议方面，伪装\u0026gt;混淆，混淆用的人一多就是死，但换句话说，只要没啥人用可以认为就是安全的\u0026hellip;所以个人决定走私人订制混淆方案的路子，低调才是出路 VPN方案 家里大部分设备直接通过ax9000上网\n部分设备通过连ax9000的wifi+设置r2s作为网关，所有流量走r2s上面的wireguard\nr2s和国外vps之间的wireguard通过udptunnel互相通信，因为udp被干扰太严重了\nDNS方案 国外vps上面的caddy代理google dns doh，r2s通过smartdns使用国外vps的doh\n国内vps通过dnscrypt-proxy使用国外vps的doh，通过bind向国内提供未被污染的dns服务（非必要）\nax9000使用国内vps提供的dns（非必要）\n流程记录 设备准备 r2s vps买好 r2s刷官方openwrt(后来才知道openwrt官网也有下载，早知道的话我会选择openwrt官网的版本)，23.05的版本换掉了iptable，为了求稳，装的21.02版本 配置wireguard ","permalink":"https://rikaaa0928.github.io/posts/openwrt-wireguard-r2s/","summary":"整体架构 家 国内 国外 r2s ( wireguard + udptunnel smartdns) -\u0026gt; ax9000 -\u0026gt; 光猫) vps ( bind dnscrypt-proxy ） vps ( caddy wireguard + udptunnel ) 整套方案的方针是\n减少复杂度，任何情况下不要影响任何不参与其中的设备，因为家里还有其他人用。所以采用旁网关的方式 尽量采用由可信的第一方直接提供的技术/组件。作者跑路，团队内讧导致使用的版本无人维护，经常出现破坏性变动，作者夹带私货等现象实在是太多了，所以采用wireguard作为vpn方案，其他xray v2ray/v2fly trojan ss ssr之类的通通pass\u0026hellip;搞出这么多东西来就足以说明了由多不靠谱 传输协议方面，伪装\u0026gt;混淆，混淆用的人一多就是死，但换句话说，只要没啥人用可以认为就是安全的\u0026hellip;所以个人决定走私人订制混淆方案的路子，低调才是出路 VPN方案 家里大部分设备直接通过ax9000上网\n部分设备通过连ax9000的wifi+设置r2s作为网关，所有流量走r2s上面的wireguard\nr2s和国外vps之间的wireguard通过udptunnel互相通信，因为udp被干扰太严重了\nDNS方案 国外vps上面的caddy代理google dns doh，r2s通过smartdns使用国外vps的doh\n国内vps通过dnscrypt-proxy使用国外vps的doh，通过bind向国内提供未被污染的dns服务（非必要）\nax9000使用国内vps提供的dns（非必要）\n流程记录 设备准备 r2s vps买好 r2s刷官方openwrt(后来才知道openwrt官网也有下载，早知道的话我会选择openwrt官网的版本)，23.05的版本换掉了iptable，为了求稳，装的21.02版本 配置wireguard ","title":"Openwrt+Wireguard+udptunnel+DoH旁网关（旁路由）方案记录"},{"content":"from ipaddress import ip_network start = \u0026#39;0.0.0.0/0\u0026#39; exclude = [\u0026#39;1.1.1.1/32\u0026#39;, \u0026#39;10.0.0.0/8\u0026#39;] result = [ip_network(start)] for x in exclude: n = ip_network(x) new = [] for y in result: if y.overlaps(n): new.extend(y.address_exclude(n)) else: new.append(y) result = new print(\u0026#39;,\u0026#39;.join(str(x) for x in sorted(result))) ","permalink":"https://rikaaa0928.github.io/posts/gen-exclude-ip/","summary":"from ipaddress import ip_network start = \u0026#39;0.0.0.0/0\u0026#39; exclude = [\u0026#39;1.1.1.1/32\u0026#39;, \u0026#39;10.0.0.0/8\u0026#39;] result = [ip_network(start)] for x in exclude: n = ip_network(x) new = [] for y in result: if y.overlaps(n): new.extend(y.address_exclude(n)) else: new.append(y) result = new print(\u0026#39;,\u0026#39;.join(str(x) for x in sorted(result))) ","title":"生成排除置顶ip段后的新ip段"},{"content":"mut a: \u0026amp;mut i32 mut a表示a可变，可以被重新绑定\n\u0026amp;表示(不可变)引用 \u0026amp;mut表示可变引用，即*a可变，可以被重新绑定\n测试验证代码 fn change_i_mut_ref(i:\u0026amp;mut i32){ *i=2; // 给引用绑定新值，i 不可变，*i 指向的变量可变 } // fn change_i_mut_ref_err(i:\u0026amp;mut i32){ // i=xxxx; // i 不可变，不可重新绑定，等于什么都不行 // } fn change_mut_i(mut i:i32){ i=4; } fn change_mut_i_ref(mut i:\u0026amp;i32){ i=\u0026amp;5; } fn change_mut_i_mut_ref_change_i(mut i:\u0026amp;mut i32){ // i=\u0026amp;5; //会报错，因为 \u0026amp;5 的类型是 \u0026amp;i32, \u0026amp;mut 5 的类型是 \u0026amp;mut i32 // i=\u0026amp;mut 5; //一样会报错，因为 \u0026amp;mut 5 生命周期仅在函数内，函数返回后，i引用的值会被回收 } fn change_mut_i_mut_ref_change_ref(mut i:\u0026amp;mut i32){ *i=7; } #[tokio::test] async fn my_test1()-\u0026gt; crate::Result\u0026lt;()\u0026gt; { let mut i=1i32; println!(\u0026#34;{}\u0026#34;,i); change_i_mut_ref(\u0026amp;mut i);// 这里需要传 \u0026amp;mut i, \u0026amp;i的类型是 \u0026amp;i32, 不是 \u0026amp;mut i32，同时i需要是mut i，不可变变量不可转化为可变引用 println!(\u0026#34;{}\u0026#34;,i); change_mut_i(i);//修改失败 println!(\u0026#34;{}\u0026#34;,i);//修改失败 change_mut_i_ref(\u0026amp;mut \u0026amp;i); println!(\u0026#34;{}\u0026#34;,i);//修改失败 change_mut_i_mut_ref_change_i(\u0026amp;mut i); println!(\u0026#34;{}\u0026#34;,i);//修改失败 change_mut_i_mut_ref_change_ref(\u0026amp;mut i); println!(\u0026#34;{}\u0026#34;,i);//修改成功，和change_i_mut_ref等效 Ok(()) } ","permalink":"https://rikaaa0928.github.io/posts/rust-learn-mut-ref/","summary":"mut a: \u0026amp;mut i32 mut a表示a可变，可以被重新绑定\n\u0026amp;表示(不可变)引用 \u0026amp;mut表示可变引用，即*a可变，可以被重新绑定\n测试验证代码 fn change_i_mut_ref(i:\u0026amp;mut i32){ *i=2; // 给引用绑定新值，i 不可变，*i 指向的变量可变 } // fn change_i_mut_ref_err(i:\u0026amp;mut i32){ // i=xxxx; // i 不可变，不可重新绑定，等于什么都不行 // } fn change_mut_i(mut i:i32){ i=4; } fn change_mut_i_ref(mut i:\u0026amp;i32){ i=\u0026amp;5; } fn change_mut_i_mut_ref_change_i(mut i:\u0026amp;mut i32){ // i=\u0026amp;5; //会报错，因为 \u0026amp;5 的类型是 \u0026amp;i32, \u0026amp;mut 5 的类型是 \u0026amp;mut i32 // i=\u0026amp;mut 5; //一样会报错，因为 \u0026amp;mut 5 生命周期仅在函数内，函数返回后，i引用的值会被回收 } fn change_mut_i_mut_ref_change_ref(mut i:\u0026amp;mut i32){ *i=7; } #[tokio::test] async fn my_test1()-\u0026gt; crate::Result\u0026lt;()\u0026gt; { let mut i=1i32; println!","title":"Rust: 可变和引用"},{"content":"java 17是java目前最新的长期支持(LTS)版本，但是由于其强封装 JDK 的内部 API的新特性，导致dubbo项目无法直接使用jdk17编译运行。通过参考openjdk的说明，可以发现只需要添加相应参数即可绕开java 17的限制\n对于普通的dubbo项目，只需要在运行时添加\n--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED\n如上参数即可。如果项目的其它依赖也有类似问题则可能需要加入更多参数，参数的获得方式和详细示例将在下面给出\n本解决方案只能解决由于java 17强封装 JDK 的内部 API的特性造成的问题，其他的兼容性问题请寻找其它方案\n参数的获得方法和示例 我们以dubbo官方仓库中的demo为例 首先使用java 17作为我们的开发环境，通过\ngit clone git@github.com:apache/dubbo.git git checkout dubbo-2.7.14 cd dubbo-demo/dubbo-demo-annotation 获得dubbo官方仓库的代码中的demo，然后可以尝试直接使用java 17编译dubbo的demo\nmvn -U clean package --no-transfer-progress -D maven.test.skip=true 启动zookeeper docker run --name some-zookeepep -p 2181:2181 -it --rm zookeeper 作为注册中心 尝试运行provider\njava -jar dubbo-demo-annotation-provider/target/dubbo-demo-annotation-provider-2.7.14.jar 可以看到类似的报错:\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not \u0026quot;opens java.lang\u0026quot; to unnamed module @8807e25\n关键词 module java.basedoes not \u0026quot;opensjava.lang\u0026quot; to unnamed module @8807e25，根据openjdk的说明，我们只需要添加--add-opens java.base/java.lang=ALL-UNNAMED参数即可解决问题\n对应的报错应该都可以用类似得方法去解决，经过测试，demo中的dubbo项目需要\n--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED 如上参数即可运行\n在两个终端中分别运行provider和consumer:\njava --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED -jar dubbo-demo-annotation-provider/target/dubbo-demo-annotation-provider-2.7.14.jar java --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED -jar dubbo-demo-annotation-consumer/target/dubbo-demo-annotation-consumer-2.7.14.jar 可以发现报出了zookeeper的错误，不难想到，升级依赖的zookeeper的版本大概率可以解决问题\u0026hellip;\n在provider和consumer的 pom.xml 的依赖第一项添加最新版本的zookeeper依赖:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 再次运行provider和consumer\n可以看到consumer端成功输出了类似的结果\nresult :Hello world, response from provider: *.*.*.*/\u0026lt;unresolved\u0026gt;:20880 provider端也有对应的日志\nHello world, request from consumer: /*.*.*.*:43346 ","permalink":"https://rikaaa0928.github.io/posts/dubbo-2.7.14-with-java-17/","summary":"java 17是java目前最新的长期支持(LTS)版本，但是由于其强封装 JDK 的内部 API的新特性，导致dubbo项目无法直接使用jdk17编译运行。通过参考openjdk的说明，可以发现只需要添加相应参数即可绕开java 17的限制\n对于普通的dubbo项目，只需要在运行时添加\n--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED\n如上参数即可。如果项目的其它依赖也有类似问题则可能需要加入更多参数，参数的获得方式和详细示例将在下面给出\n本解决方案只能解决由于java 17强封装 JDK 的内部 API的特性造成的问题，其他的兼容性问题请寻找其它方案\n参数的获得方法和示例 我们以dubbo官方仓库中的demo为例 首先使用java 17作为我们的开发环境，通过\ngit clone git@github.com:apache/dubbo.git git checkout dubbo-2.7.14 cd dubbo-demo/dubbo-demo-annotation 获得dubbo官方仓库的代码中的demo，然后可以尝试直接使用java 17编译dubbo的demo\nmvn -U clean package --no-transfer-progress -D maven.test.skip=true 启动zookeeper docker run --name some-zookeepep -p 2181:2181 -it --rm zookeeper 作为注册中心 尝试运行provider\njava -jar dubbo-demo-annotation-provider/target/dubbo-demo-annotation-provider-2.7.14.jar 可以看到类似的报错:\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.","title":"Dubbo 2.7.14 With Java 17"}]