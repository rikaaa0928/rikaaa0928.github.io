[{"content":"================================================================= = CHAPTER 1 RECAP = Use the h,j,k,l keys to move the cursor.\nType : to enter Command mode.\nThe q / quit and q! / quit! commands will exit Helix. The former fails when there are unsaved changes. The latter discards them. The w / write command will save the file. The wq / write-quit command will do both. Type d to delete the character at the cursor.\nType i to enter Insert mode and type text. Press Escape to return to Normal mode.\n================================================================= = CHAPTER 2 RECAP = Type a to append to the selection.\nType I to enter Insert mode at the first non-whitespace character at the start of a line.\nType A to enter Insert mode at the end of a line.\nUse o and O to open lines below and above the cursor respectively.\n================================================================= = CHAPTER 3 RECAP = Type w to select forward until the next word.\nType e to select to the end of the current word. Type b to select backward to the start of the current word. Use uppercase counterparts, W,E,B, to traverse WORDS. Type d to delete the entire selection.\nType c to delete the selection and enter Insert mode. Type a number before a motion to repeat it that many times.\nType v to enter Select mode, where all motions extend the selection.\nType x to select the entire current line. Type x again to select the next line.\nType semicolon ( ; ) to collapse selection.\n================================================================= = CHAPTER 4 RECAP = Type u to undo. Type U to redo.\nType y to yank (copy) text and p to paste.\nUse Space + y and Space + p to yank / paste on the system clipboard. Type / to search forward in file, and ? to search backwards.\nUse n and N to cycle through search matches. ================================================================= = CHAPTER 5 RECAP = Type C to duplicate the cursor to the next suitable line and Alt-C for previous suitable line.\nType s to select all instances of a regex pattern inside the current selection.\nType \u0026amp; to align selections.\nPress Alt-s to split the selection into lines.\n================================================================= = CHAPTER 6 RECAP = Type f / F to extend selection up to \u0026amp; including a character.\nType t / T to extend selection until a character. Type r to replace selected characters.\nType . to repeat the last insertion.\nPress Alt-. to repeat the last f / t selection. ================================================================= = CHAPTER 7 RECAP = Type R to replace the selection with yanked text.\nType J to join lines in selection.\nType \u0026gt; and \u0026lt; to indent / unindent lines.\nPress Ctrl-a to increment the selected number.\nPress Ctrl-x to decrement the selected number. ================================================================= = CHAPTER 8 RECAP = Type \u0026quot; to select a different register.\nType Q to start and stop recording a macro to a register, the default being @.\nType q to replay a macro from @ or the selected register.\n================================================================= = CHAPTER 9 RECAP = Type * to set the search register to the primary selection.\nType n / N in Select mode to add selections on each search match.\nPress Ctrl-s to save position to the jumplist.\nPress Ctrl-i and Ctrl-o to go forward and backward in the jumplist. Type gw to enable 2-character labels, and any 2 characters to jump to the corresponding label, or ESC to drop the labels.\n","permalink":"https://rikaaa0928.github.io/posts/helix-keymap/","summary":"================================================================= = CHAPTER 1 RECAP = Use the h,j,k,l keys to move the cursor.\nType : to enter Command mode.\nThe q / quit and q! / quit! commands will exit Helix. The former fails when there are unsaved changes. The latter discards them. The w / write command will save the file. The wq / write-quit command will do both. Type d to delete the character at the cursor.","title":"Helix Keymap"},{"content":"tokio中，返回的future无脑实现Send，因为tokio异步框架并不能保证单个异步任务绑定某个真实线程执行，实现Send表示这个future可以安全的跨线程执行。\nSync表示并发安全，需要跨异步任务调用的必须是Sync，可以套Mutex实现非Sync转Sync，再套Arc实现clone。\n// Sync 类型:\nArc // 当 T: Sync\nMutex // 当 T: Send\nRwLock // 当 T: Send\nAtomicBool\nAtomicI32\nVec // 当 T: Sync\nString\n\u0026amp;T // 当 T: Sync\n// 非 Sync 类型:\nRefCell // 内部可变性不是线程安全的\nCell // 同上\nRc // 引用计数不是线程安全的\n*mut T // 裸指针\n","permalink":"https://rikaaa0928.github.io/posts/rust-tokio-learn-send-sync/","summary":"tokio中，返回的future无脑实现Send，因为tokio异步框架并不能保证单个异步任务绑定某个真实线程执行，实现Send表示这个future可以安全的跨线程执行。\nSync表示并发安全，需要跨异步任务调用的必须是Sync，可以套Mutex实现非Sync转Sync，再套Arc实现clone。\n// Sync 类型:\nArc // 当 T: Sync\nMutex // 当 T: Send\nRwLock // 当 T: Send\nAtomicBool\nAtomicI32\nVec // 当 T: Sync\nString\n\u0026amp;T // 当 T: Sync\n// 非 Sync 类型:\nRefCell // 内部可变性不是线程安全的\nCell // 同上\nRc // 引用计数不是线程安全的\n*mut T // 裸指针","title":"Rust tokio: Send与Sync"},{"content":"from ipaddress import ip_network start = \u0026#39;0.0.0.0/0\u0026#39; exclude = [\u0026#39;1.1.1.1/32\u0026#39;, \u0026#39;10.0.0.0/8\u0026#39;] result = [ip_network(start)] for x in exclude: n = ip_network(x) new = [] for y in result: if y.overlaps(n): new.extend(y.address_exclude(n)) else: new.append(y) result = new print(\u0026#39;,\u0026#39;.join(str(x) for x in sorted(result))) ","permalink":"https://rikaaa0928.github.io/posts/gen-exclude-ip/","summary":"from ipaddress import ip_network start = \u0026#39;0.0.0.0/0\u0026#39; exclude = [\u0026#39;1.1.1.1/32\u0026#39;, \u0026#39;10.0.0.0/8\u0026#39;] result = [ip_network(start)] for x in exclude: n = ip_network(x) new = [] for y in result: if y.overlaps(n): new.extend(y.address_exclude(n)) else: new.append(y) result = new print(\u0026#39;,\u0026#39;.join(str(x) for x in sorted(result))) ","title":"生成排除置顶ip段后的新ip段"},{"content":"mut a: \u0026amp;mut i32 mut a表示a可变，可以被重新绑定\n\u0026amp;表示(不可变)引用 \u0026amp;mut表示可变引用，即*a可变，可以被重新绑定\n测试验证代码 fn change_i_mut_ref(i:\u0026amp;mut i32){ *i=2; // 给引用绑定新值，i 不可变，*i 指向的变量可变 } // fn change_i_mut_ref_err(i:\u0026amp;mut i32){ // i=xxxx; // i 不可变，不可重新绑定，等于什么都不行 // } fn change_mut_i(mut i:i32){ i=4; } fn change_mut_i_ref(mut i:\u0026amp;i32){ i=\u0026amp;5; } fn change_mut_i_mut_ref_change_i(mut i:\u0026amp;mut i32){ // i=\u0026amp;5; //会报错，因为 \u0026amp;5 的类型是 \u0026amp;i32, \u0026amp;mut 5 的类型是 \u0026amp;mut i32 // i=\u0026amp;mut 5; //一样会报错，因为 \u0026amp;mut 5 生命周期仅在函数内，函数返回后，i引用的值会被回收 } fn change_mut_i_mut_ref_change_ref(mut i:\u0026amp;mut i32){ *i=7; } #[tokio::test] async fn my_test1()-\u0026gt; crate::Result\u0026lt;()\u0026gt; { let mut i=1i32; println!(\u0026#34;{}\u0026#34;,i); change_i_mut_ref(\u0026amp;mut i);// 这里需要传 \u0026amp;mut i, \u0026amp;i的类型是 \u0026amp;i32, 不是 \u0026amp;mut i32，同时i需要是mut i，不可变变量不可转化为可变引用 println!(\u0026#34;{}\u0026#34;,i); change_mut_i(i);//修改失败 println!(\u0026#34;{}\u0026#34;,i);//修改失败 change_mut_i_ref(\u0026amp;mut \u0026amp;i); println!(\u0026#34;{}\u0026#34;,i);//修改失败 change_mut_i_mut_ref_change_i(\u0026amp;mut i); println!(\u0026#34;{}\u0026#34;,i);//修改失败 change_mut_i_mut_ref_change_ref(\u0026amp;mut i); println!(\u0026#34;{}\u0026#34;,i);//修改成功，和change_i_mut_ref等效 Ok(()) } ","permalink":"https://rikaaa0928.github.io/posts/rust-learn-mut-ref/","summary":"mut a: \u0026amp;mut i32 mut a表示a可变，可以被重新绑定\n\u0026amp;表示(不可变)引用 \u0026amp;mut表示可变引用，即*a可变，可以被重新绑定\n测试验证代码 fn change_i_mut_ref(i:\u0026amp;mut i32){ *i=2; // 给引用绑定新值，i 不可变，*i 指向的变量可变 } // fn change_i_mut_ref_err(i:\u0026amp;mut i32){ // i=xxxx; // i 不可变，不可重新绑定，等于什么都不行 // } fn change_mut_i(mut i:i32){ i=4; } fn change_mut_i_ref(mut i:\u0026amp;i32){ i=\u0026amp;5; } fn change_mut_i_mut_ref_change_i(mut i:\u0026amp;mut i32){ // i=\u0026amp;5; //会报错，因为 \u0026amp;5 的类型是 \u0026amp;i32, \u0026amp;mut 5 的类型是 \u0026amp;mut i32 // i=\u0026amp;mut 5; //一样会报错，因为 \u0026amp;mut 5 生命周期仅在函数内，函数返回后，i引用的值会被回收 } fn change_mut_i_mut_ref_change_ref(mut i:\u0026amp;mut i32){ *i=7; } #[tokio::test] async fn my_test1()-\u0026gt; crate::Result\u0026lt;()\u0026gt; { let mut i=1i32; println!","title":"Rust: 可变和引用"},{"content":"java 17是java目前最新的长期支持(LTS)版本，但是由于其强封装 JDK 的内部 API的新特性，导致dubbo项目无法直接使用jdk17编译运行。通过参考openjdk的说明，可以发现只需要添加相应参数即可绕开java 17的限制\n对于普通的dubbo项目，只需要在运行时添加\n--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED\n如上参数即可。如果项目的其它依赖也有类似问题则可能需要加入更多参数，参数的获得方式和详细示例将在下面给出\n本解决方案只能解决由于java 17强封装 JDK 的内部 API的特性造成的问题，其他的兼容性问题请寻找其它方案\n参数的获得方法和示例 我们以dubbo官方仓库中的demo为例 首先使用java 17作为我们的开发环境，通过\ngit clone git@github.com:apache/dubbo.git git checkout dubbo-2.7.14 cd dubbo-demo/dubbo-demo-annotation 获得dubbo官方仓库的代码中的demo，然后可以尝试直接使用java 17编译dubbo的demo\nmvn -U clean package --no-transfer-progress -D maven.test.skip=true 启动zookeeper docker run --name some-zookeepep -p 2181:2181 -it --rm zookeeper 作为注册中心 尝试运行provider\njava -jar dubbo-demo-annotation-provider/target/dubbo-demo-annotation-provider-2.7.14.jar 可以看到类似的报错:\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not \u0026quot;opens java.lang\u0026quot; to unnamed module @8807e25\n关键词 module java.basedoes not \u0026quot;opensjava.lang\u0026quot; to unnamed module @8807e25，根据openjdk的说明，我们只需要添加--add-opens java.base/java.lang=ALL-UNNAMED参数即可解决问题\n对应的报错应该都可以用类似得方法去解决，经过测试，demo中的dubbo项目需要\n--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED 如上参数即可运行\n在两个终端中分别运行provider和consumer:\njava --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED -jar dubbo-demo-annotation-provider/target/dubbo-demo-annotation-provider-2.7.14.jar java --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED -jar dubbo-demo-annotation-consumer/target/dubbo-demo-annotation-consumer-2.7.14.jar 可以发现报出了zookeeper的错误，不难想到，升级依赖的zookeeper的版本大概率可以解决问题\u0026hellip;\n在provider和consumer的 pom.xml 的依赖第一项添加最新版本的zookeeper依赖:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.zookeeper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 再次运行provider和consumer\n可以看到consumer端成功输出了类似的结果\nresult :Hello world, response from provider: *.*.*.*/\u0026lt;unresolved\u0026gt;:20880 provider端也有对应的日志\nHello world, request from consumer: /*.*.*.*:43346 ","permalink":"https://rikaaa0928.github.io/posts/dubbo-2.7.14-with-java-17/","summary":"java 17是java目前最新的长期支持(LTS)版本，但是由于其强封装 JDK 的内部 API的新特性，导致dubbo项目无法直接使用jdk17编译运行。通过参考openjdk的说明，可以发现只需要添加相应参数即可绕开java 17的限制\n对于普通的dubbo项目，只需要在运行时添加\n--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED\n如上参数即可。如果项目的其它依赖也有类似问题则可能需要加入更多参数，参数的获得方式和详细示例将在下面给出\n本解决方案只能解决由于java 17强封装 JDK 的内部 API的特性造成的问题，其他的兼容性问题请寻找其它方案\n参数的获得方法和示例 我们以dubbo官方仓库中的demo为例 首先使用java 17作为我们的开发环境，通过\ngit clone git@github.com:apache/dubbo.git git checkout dubbo-2.7.14 cd dubbo-demo/dubbo-demo-annotation 获得dubbo官方仓库的代码中的demo，然后可以尝试直接使用java 17编译dubbo的demo\nmvn -U clean package --no-transfer-progress -D maven.test.skip=true 启动zookeeper docker run --name some-zookeepep -p 2181:2181 -it --rm zookeeper 作为注册中心 尝试运行provider\njava -jar dubbo-demo-annotation-provider/target/dubbo-demo-annotation-provider-2.7.14.jar 可以看到类似的报错:\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.","title":"Dubbo 2.7.14 With Java 17"}]